# 设计模式 (Design Patterns)

设计模式是软件设计中常见问题的典型解决方案，它们是被反复使用、经过分类编目的代码设计经验总结。以下是主要设计模式的分类和概述：

## 创建型模式 (Creational Patterns)

处理对象创建机制，提供灵活的对象创建方式

1. **单例模式 (Singleton)**
   - 确保一个类只有一个实例，并提供全局访问点
   - 应用场景：数据库连接、日志记录器
2. **工厂方法模式 (Factory Method)**
   - 定义创建对象的接口，让子类决定实例化哪个类
   - 应用场景：UI框架中的控件创建
3. **抽象工厂模式 (Abstract Factory)**
   - 创建相关或依赖对象的家族，而不需要明确指定具体类
   - 应用场景：跨平台UI组件
4. **建造者模式 (Builder)**
   - 分步骤构建复杂对象，允许改变产品的内部表示
   - 应用场景：复杂对象的构造(如SQL查询构建)
5. **原型模式 (Prototype)**
   - 通过复制现有对象来创建新对象
   - 应用场景：对象创建成本高时

## 结构型模式 (Structural Patterns)

处理类和对象的组合，形成更大的结构

1. **适配器模式 (Adapter)**
   - 将一个类的接口转换成客户希望的另一个接口
   - 应用场景：旧系统集成、第三方库适配
2. **桥接模式 (Bridge)**
   - 将抽象与实现分离，使它们可以独立变化
   - 应用场景：跨平台应用开发
3. **组合模式 (Composite)**
   - 将对象组合成树形结构以表示"部分-整体"层次结构
   - 应用场景：文件系统、UI组件树
4. **装饰器模式 (Decorator)**
   - 动态地给对象添加额外的职责
   - 应用场景：I/O流处理、中间件
5. **外观模式 (Facade)**
   - 为子系统中的一组接口提供统一的简化接口
   - 应用场景：复杂API的简化封装
6. **享元模式 (Flyweight)**
   - 通过共享技术有效地支持大量细粒度对象
   - 应用场景：文本编辑器中的字符处理
7. **代理模式 (Proxy)**
   - 为其他对象提供一种代理以控制对这个对象的访问
   - 应用场景：远程代理、虚拟代理、保护代理

## 行为型模式 (Behavioral Patterns)

处理对象间的通信和责任分配

1. **责任链模式 (Chain of Responsibility)**
   - 将请求的发送者和接收者解耦，使多个对象都有机会处理请求
   - 应用场景：事件处理系统、异常处理
2. **命令模式 (Command)**
   - 将请求封装为对象，支持可撤销操作
   - 应用场景：事务系统、宏命令
3. **解释器模式 (Interpreter)**
   - 定义语言的文法，并解释该语言中的句子
   - 应用场景：SQL解析、正则表达式
4. **迭代器模式 (Iterator)**
   - 提供一种方法顺序访问聚合对象中的元素
   - 应用场景：集合遍历
5. **中介者模式 (Mediator)**
   - 定义一个中介对象来封装一系列对象间的交互
   - 应用场景：GUI组件通信
6. **备忘录模式 (Memento)**
   - 在不破坏封装性的前提下捕获并外部化对象的内部状态
   - 应用场景：撤销操作、游戏存档
7. **观察者模式 (Observer)**
   - 定义对象间的一对多依赖关系，当一个对象状态改变时自动通知依赖对象
   - 应用场景：事件处理系统、MVC模式
8. **状态模式 (State)**
   - 允许对象在其内部状态改变时改变它的行为
   - 应用场景：工作流引擎、游戏角色状态
9. **策略模式 (Strategy)**
   - 定义一系列算法，封装每个算法，并使它们可互换
   - 应用场景：排序算法、支付方式选择
10. **模板方法模式 (Template Method)**
    - 定义算法骨架，将某些步骤延迟到子类实现
    - 应用场景：框架设计、标准化流程
11. **访问者模式 (Visitor)**
    - 表示一个作用于某对象结构中的各元素的操作
    - 应用场景：编译器语法树分析

## 设计模式的选择原则

1. **优先组合而非继承** - 组合更灵活，减少类之间的耦合
2. **针对接口编程** - 而不是针对实现编程
3. **识别变化点** - 将变化的部分封装起来
4. **单一职责原则** - 一个类应该只有一个引起变化的原因
5. **开闭原则** - 对扩展开放，对修改关闭

设计模式不是银弹，过度使用会导致代码复杂化。应根据实际问题选择合适的设计模式，而不是为了使用模式而使用模式。